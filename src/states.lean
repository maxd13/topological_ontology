import 
    -- data.real.basic
    -- topology.instances.real
    -- measure_theory.borel_space
    -- measure_theory.measure_space
    substances

universe u
open set topological_space classical
local attribute [instance] prop_decidable

namespace ontology

 -- Substances have `states`, although the states of simple
 -- substances are trivial.
 
 variables {ω : ontology} (s : ω.substance)
 include ω
 
 -- The state of a substance at some 
 -- possible world is the set of its subsistents existing at the world.
  def substance.state (w : ω.world) : set ω.entity :=
  s.up.subsistents ∩ w.entities
 
  lemma exists_iff_in_state : ∀ {w : ω.world} {s : ω.substance}, w ∈ s.exists ↔ s.up ∈ s.state w :=
   begin
       intros,
       constructor; intro h;
       simp[substance.state, h] at *,
       exact h,
   end

  lemma exists_iff_nonempty_state : ∀ {w : ω.world} {s : ω.substance}, w ∈ s.exists ↔ (s.state w).nonempty := 
    begin 
        intros,
        convert exists_iff_in_state; try{assumption},
        simp, constructor; intro h, swap,
            exact nonempty_of_mem h,
        simp [set.nonempty, substance.state] at h,
        obtain ⟨e, se, we⟩ := h,
        have c := entails_of_subsist se we,
        unfold_coes at c,
        exact exists_iff_in_state.mp c,
    end

 -- The state equivalence of possible worlds generated by a substance
 def substance.equiv (w₁ w₂ : ω.world) :=
    s.state w₁ = s.state w₂
 
 lemma substance.equiv_sound : equivalence s.equiv :=
  begin
    repeat{fsplit},
        simp [reflexive, substance.equiv],
        simp [symmetric, substance.equiv],
            intros x y h,
            rw h,
        simp [transitive, substance.equiv],
            intros x y z h₁ h₂,
            rwa ←h₁ at h₂,
  end
 
 def substance.State_setoid : setoid ω.world :=
 ⟨s.equiv, s.equiv_sound⟩


end ontology