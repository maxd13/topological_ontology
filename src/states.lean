import 
    -- data.real.basic
    -- topology.instances.real
    -- measure_theory.borel_space
    -- measure_theory.measure_space
    ontology

universe u
open set topological_space classical
local attribute [instance] prop_decidable

namespace ontology

 -- Substances have `states`, altough the states of metaphysical
 -- substances are trivial.
 
 variables {ω : ontology} (s : ω.substance)
 include ω
 
 -- The state of an entity at some 
 -- possible world viewed as a set of its accidents:
  def substance.state_set (w : ω.world) : set ω.accident :=
  s.accidents ∩ world.accidents w
 
 -- The state equivalence of possible worlds generated by a substance
 def substance.equiv (w₁ w₂ : ω.world) :=
    s.state_set w₁ = s.state_set w₂
 
 lemma substance.equiv_sound : equivalence s.equiv :=
  begin
    repeat{fsplit},
        simp [reflexive, substance.equiv],
        simp [symmetric, substance.equiv],
            intros x y h,
            rw h,
        simp [transitive, substance.equiv],
            intros x y z h₁ h₂,
            rwa ←h₁ at h₂,
  end
 
 def substance.state_setoid : setoid ω.world :=
 ⟨s.equiv, s.equiv_sound⟩
 
 
 -- The type of states of a substance
 @[reducible]
 def substance.state := quotient s.state_setoid
 
 -- The quotient map from worlds to states,
 -- which ontologically grounds set of states as entities.
--  @[reducible]
--  def substance.f := @quotient.mk ω.world s.state_setoid
 
 @[reducible]
 def substance.state_at (w : ω.world) := @quotient.mk ω.world s.state_setoid w
 
 -- Recall that the quotient of a topological space
 -- is itself a topological space. Therefore the type
 -- of states of a substance is naturally endowed with 
 -- topological structure. A set of states will be open 
 -- if and only if the set of all worlds in which the substance is
 -- in one of the states is itself open, so any nonempty set of states
 -- can only be open if there is some entity which exists precisely in
 -- the worlds in which the entity has one of those states. 
 -- Therefore any nonempty set of states is ontologically grounded,
 -- and so we can consider any such set to be an ontologically grounded
 -- property of the substance, and this we call a perfection.
 
 @[reducible]
 def substance.event := set s.state
 
 structure substance.perfection :=
    -- the event of the perfection existing in the substance
    (exist : s.event)
    (is_open : is_open exist)
    (ne : exist.nonempty)
    (nuniv : exist ≠ univ)
 
 -- We added nuniv because the necessary s.event should not really
 -- be considered an internal perfection of the substance, since it
 -- is grounded in the nb and is always necessary.
 
 -- Accidents of a substance are perfections of the same substance.
 -- The most important step in this proof is to show that they are open.
 lemma state_open_of_accident : ∀ (a: ω.accident), a.inheres s → is_open (s.state_at '' a.val.exist) :=
 begin
    intros a H,
    apply is_open_coinduced.2,
    simp [preimage],
    let α := {x : ω.world | ∃ (x_1 : ω.world), x_1 ∈ (a.val).exist ∧ substance.equiv s x_1 x},
    suffices c : is_open α,
        exact c,
    suffices c : α  = a.val.exist,
        rw c,
        exact a.val.is_open,
    ext, constructor; intro h; simp at *,
        obtain ⟨y, h₁, h₂⟩ := h,
        simp [substance.equiv, substance.state_set] at h₂,
        simp [ontology.world.accidents, substance.accidents] at h₂,
        have c : {a : ω.accident | a.inheres s} ∩ {a : ω.accident | y ∈ (a.val).exist} ⊆
                 {a : ω.accident | a.inheres s} ∩ {a : ω.accident | x ∈ (a.val).exist},
        rw h₂,
        exact and.right (@c a ⟨H, h₁⟩),
    existsi x,
    constructor,
        assumption,
    obtain ⟨res, _, _⟩ := substance.equiv_sound s,
    exact res x,
 end
 
 -- It should then be easier to prove that it is not empty
 lemma state_ne_of_accident : ∀ (a: ω.accident), a.inheres s → (s.state_at '' a.val.exist).nonempty :=
 begin
    intros a H,
    simp [preimage],
    exact a.val.ne,
 end
 
 -- But it is a little bit harder to prove it is not univ
 lemma state_nuniv_of_accident : ∀ (a: ω.accident), a.inheres s → (s.state_at '' a.val.exist) ≠ univ :=
 begin
    intros a H,
    simp [preimage, image, quotient.mk],
    intro h,
    -- This is a trick
    -- let ψ := (@quotient.mk world ontology.substance.state_setoid),
    replace h : univ ⊆ {b : quotient s.state_setoid | ∃ (a_1 : ω.world), a_1 ∈ (a.val).exist ∧ s.state_at a_1 = b},
        rw ←h,
        -- refl,
    have c : s.val.exist = a.val.exist,
    ext, constructor; intro h₁,--; simp at *,
        have c := @h (s.state_at x) _,
        simp at c,
        obtain ⟨y, c₁, c₂⟩ := c,
        replace c₂ : s.equiv y x := c₂,
        simp [substance.equiv, substance.state_set] at c₂,
        simp [ontology.world.accidents, substance.accidents] at c₂,
        have c : {a : ω.accident | a.inheres s} ∩ {a : ω.accident | y ∈ (a.val).exist} ⊆
                 {a : ω.accident | a.inheres s} ∩ {a : ω.accident | x ∈ (a.val).exist},
        rw c₂,
        exact and.right (@c a ⟨H, c₁⟩),
            trivial,
        revert x,
        apply sub_of_inheres,
        exact H,
    have c₁ : s.val.exist.dense := s.property,
    have c₂ : ¬ a.val.exist.dense := a.property,
    rw c at c₁,
    contradiction,
 end
 
 -- Finally we can construct the perfection.
 def substance.perfection_of (a ∈ s.accidents) : s.perfection :=
    ⟨ s.state_at '' a.val.exist
    , state_open_of_accident s a H
    , state_ne_of_accident s a H
    , state_nuniv_of_accident s a H
    ⟩
 
 -- perfections which come from accidents
 @[reducible]
 def substance.aperfections := {p : s.perfection | ∃ a ∈ s.accidents, (s.perfection_of a H) = p}
 
 -- events which come from accidents
 @[reducible]
 def substance.aevents := {p : s.event | ∃ a ∈ s.accidents, (s.perfection_of a H).exist = p}
 
 instance state_has_mem : has_mem s.perfection s.state :=
 ⟨λ p s, s ∈ p.exist⟩
 @[reducible]
 def perfections (x : s.state) := {p : s.perfection | p ∈ x}
 
 -- We can also build a neighborhood for any state
 -- which is an aperfection in case the substance has
 -- accidents in that state and the whole space otherwise.
 
 structure nhd {s : ω.substance} (x : s.state) :=
    (U : s.event)
    (is_open : is_open U)
    (elem : x ∈ U)
 
 noncomputable def state.nhd_default {s : ω.substance} (x : s.state) : nhd x :=
    begin
        classical,
        set elab_help := s.state_setoid,
        -- lets build a world which maps to x
        -- and has some accident, the associated perfection of which
        -- will be our neighborhood. If no such world exists, we
        -- will just use univ.
        by_cases w : ∃w, ⟦w⟧ = x ∧ (∃a : ω.accident, a.inheres s ∧ a.val ∈ w),
        swap,
            exact ⟨univ, is_open_univ, by simp⟩,
        replace w := nonempty_subtype.2 w,
        replace w := classical.choice w,
        obtain ⟨w, hw, a⟩ := w,
        replace a := nonempty_subtype.2 a,
        replace a := classical.choice a,
        obtain ⟨a, ha₁, ha₂⟩ := a,
        -- a is now our wanted accident.
        let p := s.perfection_of a ha₁,
        -- it is now easier to build the neighborhood.
        fconstructor,
            exact p.exist,
            exact p.is_open,
        rw ←hw,
        simp [p,substance.perfection_of],
        existsi w,
        exact ⟨ha₂, rfl⟩,
    end
 
 -- Each contingent substance has a bottom state. For a contingent substance
 -- this is the "state" in which the substance does not exist.
 
 --  lemma aux : contingent s → ∀ w, 
 
 --  def aux (h : contingent s) : nonempty (subtype s.val.exist.compl) := sorry
  
 --  @[reducible]
 --  noncomputable def state_bot (h : contingent s) : s.state :=
 --      have c : ¬ ∀ x, x ∈ s.val.exist,
 --         by {obtain ⟨⟨exist, is_open, nes⟩, perfect⟩ := s,
 --             intro h',
 --             replace h' := eq_univ_of_forall h',
 --             simp [contingent, nb, nbe] at h,
 --             simp at h',
 --             contradiction,
 --            },
 --     --  φ $
 --     --  classical.choice $
 --     --  nonempty_of_exists $
 --     --  not_forall.mp c
 --     -- have d : nonempty (subtype s.val.exist.compl),
 --     --     begin 
 --     --         replace c := not_forall.mp c,
 --     --         obtain ⟨x, hx⟩ := c,
 --     --         constructor,
 --     --         exact ⟨x, hx⟩,
 --     --     end,
 --     φ $
 --     subtype.val $
 --     choice $
 --     aux h
        
 
 
 
 --   begin
 --     classical,
 --     obtain ⟨⟨exist, is_open, nes⟩, perfect⟩ := s,
 --     simp [contingent, nb, nbe] at h,
 --     set s : ω.substance := ⟨⟨exist, is_open, nes⟩, perfect⟩,
 --     have c : ¬ ∀ x, x ∈ exist,
 --         intro h',
 --         replace h' := eq_univ_of_forall h',
 --         contradiction,
 --     replace c := not_forall.mp c,
 --     replace c := nonempty_of_exists c,
 --     replace c := classical.choice c,
 --     exact φ s c,
 --   end
 
 -- set_option trace.elaborator_detail true
 --  lemma bot_no_accidents (h : contingent s) : (s.state_set (@quotient.out _ s.state_setoid (state_bot h))) = ∅ :=
 --     begin
 --         set elab_help := s.state_setoid,
 --         simp [substance.state_set],
 --         apply eq_empty_iff_forall_not_mem.2,
 --         intro x,
 --         simp,
 --         -- simp [state_bot, ontology.φ],
 --         intros h₂ h₃,
 --         -- simp at h₃,
 --         have d := sub_of_inheres x s h₂,
 --         replace h₃ := d h₃,
 --         -- simp [(choice (aux s h)).property] at h₃,
 --         -- set c := subtype.val (choice (aux s h),
 --         -- let c := quotient.mk_out ⟦(choice (aux s h)).val⟧,
 --         -- simp [quotient.out],
 --     end
 
 -- The bottom has no perfections.
 -- For the necessary being it is rather that
 -- we should consider it to have a single necessary
 -- informal "perfection" which is the set which 
 -- contains only the unique state of the nb.
 --   lemma state_bot_empty : perfections ⊥ = ∅ :=
 --    begin
 --     classical,
 --     set elab_help := s.state_setoid,
 --      simp [perfections],
 --      apply eq_empty_of_subset_empty,
 --      intros p hp,
 --      simp at *,
 --      let e := quotient.mk⁻¹' p.exist,
 --      let state := p.ne.some,
 --      have c : is_open e ∧ e.nonempty,
 --         constructor,
 --         exact p.is_open,
 --         simp [set.nonempty],
 --         use state.out,
 --         simp,
 --         exact p.ne.some_mem,
 --     let e₂ : entity := ⟨e, c.1, c.2⟩, 
 --         -- apply mem_preimage.2,
 --         -- exact p.ne,
 --         -- focus {library_search},
 --     --  by_cases contingent s;
 --     --  simp [has_bot.bot, h, has_mem.mem] at hp,
      
 --    end
 
 -- Every state space is T0 but not T1, so that its specialization order
 -- has a botton element. For a contingent substance
 -- this is the "state" in which the substance does not exist.
 -- For the necessary being it is its unique state.
 --  instance state_order_bot : order_bot s.state :=
 --   begin
 --     classical,
 --     fconstructor,
 --         by_cases contingent s,
 --             obtain ⟨⟨exist, is_open, nes⟩, perfect⟩ := s,
 --             simp [contingent, nb, nbe] at h,
 --             set s : ω.substance := ⟨⟨exist, is_open, nes⟩, perfect⟩,
 --             have c : ¬ ∀ x, x ∈ exist,
 --                 intro h',
 --                 replace h' := eq_univ_of_forall h',
 --                 contradiction,
 --             replace c := not_forall.mp c,
 --             replace c := nonempty_of_exists c,
 --             replace c := classical.choice c,
 --             exact φ s c,
 --         exact φ s (default world),
 --     intros x₁ x₂,
 --     exact ∀ p : s.perfection, p ∈ x₁ → p ∈ x₂,
 --         intros x p h,
 --         exact h,
 --     intros x y z h₁ h₂ p hp,
 --     exact h₂ p (h₁ p hp),
 --         intros x y h₁ h₂,
 --         admit,
 --     intros x p hp,
 --     by_cases contingent s;
 --     simp [h] at hp,
 --   end
 
 
 -- Next we wish to show that the perfections which come from accidents
 -- form a basis.
 --  lemma accidents_nhds : ∀ (w : s.state) (U : set s.state), w ∈ U → is_open U → ∃ V ∈ s.aevents, w ∈ V ∧ V ⊆ U :=
 --  begin
 --      intros w U H op,
 --  end
 
 --  #check is_topological_basis_of_open_of_nhds
 
 -- Then we want to show that unions of accidents also map
 -- to perfections, and that all perfections are generated this way.
 
end ontology